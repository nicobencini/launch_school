{"User Input": "print('Welcome to program')\nuser_input = input('Select language: 1) English 2) Spanish')", 
"Current Directory": "import os\nproject_directory = os.path.dirname(os.path.abspath(__file__))", 
"Falsy": "In Python, the falsy values include False, 0, 0.0, None, \"\", and empty collections like [], () and {}. All other values, the truthy values, are said to evaluate to true. Note that saying that a value evaluates to true or false is not the same as saying that those values are True or False, or that they are equal to True or False. ", 
"Truthy": "In Python, the falsy values include False, 0, 0.0, None, \"\", and empty collections like [], () and {}. All other values, the truthy values, are said to evaluate to true. Note that saying that a value evaluates to true or false is not the same as saying that those values are True or False, or that they are equal to True or False. ", 
"Literals": "You can use literals to represent most data type values. A literal is any syntactic notation that lets you directly represent an object in source code. For instance, all of the following are literals in Python:\n'Hello, world!'   # str literal \n3.141592          # float literal\nTrue              # bool literal\n{'a': 1, 'b': 2}  # dict literal\n[1, 2, 3]         # list literal\n(4, 5, 6)         # tuple literal\n{7, 8, 9}         # set literal",
"Read Json File": "import json\nwith open(PATH, 'r') as f:\n    info_dictionary = json.load(f)",
"Write Json File": "import json\nwith open(PATH, 'w') as f:\n    json.dump(info_dictionary, f)",
"Primatives": "These are the most primitive or basic data structures. Python has four primitive data types which include integers, floats, strings, and booleans.",
"Sort List Alphabetically": "sorted(lst)",
"Variables": "Variables are merely names used to identify values (that is, data). In fact, they are also called identifiers, a more general term that applies to variables, constants, function names, class names, and more.All of the following should be treated as variables:\n-Variables and constants\n-Function names\n-Function parameters\n\nNote in particular that dictionary key names are not variables, nor are the elements of a collection.",
"Tuples": "A crucial distinction between lists and tuples is that lists are mutable. Tuples, however, are immutable. \nList literals use square brackets [] surrounding a comma-delimited list of values, while tuples use parentheses ().\nYou can access objects in a list or tuple with the [] indexing syntax. The value between the brackets must be an integer between 0 and the length of the sequence minus 1\nThe immutability of tuples limits their usefulness slightly, but Python can perform more optimizations on tuples.",
"Mutable": "Mutable types are types whose objects can be altered after they are created. So, for example, we can add, remove, and replace elements in a list. Immutable types can't be altered after creation. Instead, you must create a new object with a different value.\nThe following data-types are mutable: \n    -List\n    -Dictionaries\n    -Sets\n    -Functions\nThe following data types are immutabile:\n    -Integers\n    -Floats\n    -Boolean\n    -Strings\n    -Ranges\n    -Tuples\n    -Frozen Sets\n    -NoneType",
"Set": "Sets represent an unordered collection of unique objects; the objects are sometimes called the members of the set. Sets are similar to maps, except instead of using keys and values, a set is simply a collection of immutable objects. The literal syntax for sets is a comma-separated list of object values between curly braces ({}). As a special case, empty sets must be created with the set constructor since {} by itself is an empty dictionary. There are two main set types: ordinary sets (class set) and frozen sets (class frozenset). Frozen sets are merely immutable sets. They also lack a literal syntax: you must use the frozenset function to create one. \ns1 = set()      # Empty set\ns2 = {2, 3, 5, 7, 11, 13}      # Create a set from a literal",
"Integer Division": "The // operator returns the largest whole number less than or equal to the floating point result. That is, it rounds the result down to the nearest whole number. Thus, 16 // 3 returns 5, not 5.333333333333333. Likewise, 16 // -3 returns -6. If either operand is a float, the return value is also a float, but it's still rounded down to a whole number.",
"Modulo": "Python's % operator returns the modulus of a division, not the remainder. Some programmers incorrectly call it the remainder operator. There is a mathematical distinction between modulo and remainder operations. This distinction differs when precisely one of the two numbers is negative. As long as both numbers have the same sign, modulo and remainder are equivalent operations.",
"Coercion": "Many programming languages support the conversion of a value into another of a different data type. This kind of type conversions can be implicitly or explicitly made. Implicit conversion, which is also called coercion, is automatically done. Explicit conversion, which is also called casting, is performed by code instructions. In Python this is done as follows:\nprint(str(5))",
"Get Type": "print(type(1))         # <class 'int'>\nprint(type('abc') is str)     # True\nprint(type('abc').__name__)   # str",
"String Representations": "You can use the str and repr functions with any object. They each return a string representation of an object. The str function returns a string intended to be something that humans can read. It is often used when printing an object. Python implicitly calls str() when it needs to print or interpolate a value. The repr function is a bit lower-level. It returns a string that you can, in theory, use to create a new instance of the object.",
"String Length": "print(len('Food'))",
"Expression": "An expression combines values, variables, operators, and calls to functions to produce a new object. Expressions must be evaluated to determine the expression's value. Examples of expressions include:\nLiterals: 5, 'Karl', 3.141592, True, None\nVariable references: foo or name when these variables have been previously defined.\nArithmetic operations: x + y or a * b - 5.\nComparison operations: 'x' == 'x' or 'x' < 'y'.\nString operations: 'x' + 'y' or 'x' * 32.\nFunction calls: print('Hello') or len('Python').\nAny valid combination of the above that evaluates to a single object.\nYou can think of an expression as something that has a value.",
"Statement": "A statement, on the other hand, is an instruction that tells Python to perform an action of some kind. Unlike expressions, statements don't return values. They do something but don't produce a value as expressions do.\nExamples of statements include:\nAssignment: like x = 5. This doesn't evaluate as a value; it assigns a value to a variable.\nControl flow: such as if, else, while, for, and so on. These determine the flow of your program but don't evaluate as a value themselves.\nFunction and class definitions: using def or class.\nReturn statements: like return x, which tells a function to exit and return a value. return itself doesn't return a value; it informs the function what value it should return.\nImport statements: such as import math.",
"Variable": "A variable is a label attached to a specific value stored in a program's memory. Typically, variables can be changed; we can connect the variable to a different value somewhere else in memory.",
"Style Convention": "Use snake_case formatting for most identifiers (excluding constant and class names).\nUse SCREAMING_SNAKE_CASE formatting for constant names.\nUse PascalCase/CamelCase formatting for class names.",
"String Slicing": "test_string[::2] #Get first 2 characters of string\ntest_string[2:4] #Get third and forth characters of string\ntest_string[2::] #Get from 3rd char onwards",
"Constant": "Constants are unchanging values that should never be reassigned. Constants are usually defined in the global scope. The definitions are usually written at the top of the program file, just below any imports. You can use constants anywhere, but they should be defined globally. Thus, you can use constants in functions, but you shouldn't create a constant inside a function.\n\nPython does not support true constants. Instead, the SCREAMING_SNAKE_CASE naming convention is solely for programmers. For instance, the name FIRST_BASE meets the naming conventions for constants, so you should think of FIRST_BASE as a constant. However, since Python places no constraints on such names, you can easily change the value assigned to FIRST_BASE. Changing a constant's value is poor practice and may make you unpopular at work."


}